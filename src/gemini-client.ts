import { GoogleGenerativeAI, Candidate } from "@google/generative-ai"; // Assuming Candidate is exported
import { z } from "zod";
import { getLogger } from "./logging.ts";

// Define types to remove 'any'
interface UrlContextTool {
  urlContext: Record<string, never>;
}

interface GoogleSearchTool {
  googleSearch: Record<string, never>;
}

type GeminiTool = UrlContextTool | GoogleSearchTool;

interface WebSource {
  uri: string;
}

interface GroundingChunk {
  web?: WebSource;
}

interface SearchEntryPoint {
  renderedContent?: string;
}

interface GroundingMetadata {
  groundingChunks?: GroundingChunk[];
  searchEntryPoint?: SearchEntryPoint;
}

interface UrlContextItem {
  url?: string;
}

// It's possible the library exports a more precise Candidate type.
// If `Candidate` from the import is sufficient and structured correctly,
// we might not need GeminiCandidate. For now, let's assume we might need to be more specific
// or that the imported Candidate is generic.
// We will try to use the imported `Candidate` type first and cast to a more specific
// local type if its properties (like groundingMetadata) are not directly on it or are too generic.
// For the purpose of this exercise, let's assume `Candidate` itself might be `any` or too broad,
// and define our own structure for the parts we are interested in.

interface GeminiCandidateParts {
  urlContextMetadata?: UrlContextItem | UrlContextItem[];
  groundingMetadata?: GroundingMetadata;
  // This will be used to cast `candidate` if the imported `Candidate` type is not specific enough.
}


const ConfigSchema = z.object({
  apiKey: z.string().min(1, "API key is required"),
});

/**
 * Defines the request structure for the Gemini API.
 */
export interface GeminiRequest {
  /** The main text prompt for the AI. */
  prompt: string;
  /**
   * Optional temperature for controlling randomness.
   * Typically ranges from 0.0 to 2.0. Defaults to 0.7 if not set.
   */
  temperature?: number;
  /**
   * Optional maximum number of tokens to generate.
   * Defaults to 4096 if not set.
   */
  maxTokens?: number;
}

/**
 * Defines the response structure from the Gemini API.
 */
export interface GeminiResponse {
  /** The primary text content generated by the AI. */
  text: string;
  /** Optional metadata, including sources and search suggestions. */
  metadata?: {
    /** URLs of web pages or documents used as sources. */
    sources?: string[];
    /** Suggested follow-up searches or queries. */
    searchSuggestions?: string[];
  };
}

/**
 * A client for interacting with the Google Gemini API.
 * It handles request construction, API calls, and response parsing.
 */
export class GeminiClient {
  private genAI: GoogleGenerativeAI;

  /**
   * Constructs a new GeminiClient.
   *
   * @param apiKey - The Google Gemini API key. If not provided, it attempts to read from the `GEMINI_API_KEY` environment variable.
   * @param genAIInstance - An optional instance of `GoogleGenerativeAI`. Used primarily for testing to inject a mock instance.
   *                      If not provided, a new instance is created using the `apiKey`.
   * @throws {Error} If the API key is not provided and not found in the environment.
   */
  constructor(apiKey?: string, genAIInstance?: GoogleGenerativeAI) {
    if (genAIInstance) {
      this.genAI = genAIInstance;
    } else {
      const config = ConfigSchema.parse({
        apiKey: apiKey || Deno.env.get("GEMINI_API_KEY"),
      });
      this.genAI = new GoogleGenerativeAI(config.apiKey);
    }
  }

  /**
   * Generates content using the Gemini model based on the provided request.
   *
   * @param request - The `GeminiRequest` object containing the prompt and other parameters.
   * @returns A promise that resolves to a `GeminiResponse` object containing the generated text and metadata.
   * @throws {Error} If the API call fails or returns an error. Errors are logged before being re-thrown.
   */
  async generate(request: GeminiRequest): Promise<GeminiResponse> {
    try {
      const defaultModel = "gemini-2.5-pro-preview-06-05";
      const modelFromEnv = Deno.env.get("GEMINI_MODEL_NAME");
      const modelNameToUse = modelFromEnv && modelFromEnv.trim() !== "" ? modelFromEnv.trim() : defaultModel;

      const model = this.genAI.getGenerativeModel({
        model: modelNameToUse,
        tools: [{ urlContext: {} }, { googleSearch: {} }] as GeminiTool[],
      });

      const result = await model.generateContent({
        contents: [{ role: "user", parts: [{ text: request.prompt }] }],
        generationConfig: {
          temperature: request.temperature ?? 0.7,
          maxOutputTokens: request.maxTokens ?? 4096,
        },
      });

      const response = await result.response;
      const candidate = response.candidates?.[0];
      const sources: string[] = [];

      // Assuming candidate might be of a generic type from the library,
      // or we need to access nested properties not directly on the base Candidate type.
      // If `candidate` is already well-typed by the library's `Candidate` import, this cast might be simplified.
      const specificCandidateData = candidate as GeminiCandidateParts | undefined;

      // URL context sources
      if (specificCandidateData?.urlContextMetadata) {
        const { urlContextMetadata } = specificCandidateData;
        if (Array.isArray(urlContextMetadata)) {
          urlContextMetadata.forEach((item) => {
            if (item?.url) sources.push(item.url);
          });
        } else if (urlContextMetadata.url) {
          sources.push(urlContextMetadata.url);
        }
      }
      
      // Grounding metadata sources
      if (specificCandidateData?.groundingMetadata?.groundingChunks) {
        specificCandidateData.groundingMetadata.groundingChunks.forEach((chunk) => {
          if (chunk?.web?.uri) sources.push(chunk.web.uri);
        });
      }

      return {
        text: response.text(),
        metadata: {
          sources: [...new Set(sources)], // Remove duplicates
          searchSuggestions: specificCandidateData?.groundingMetadata?.searchEntryPoint?.renderedContent
            ? [specificCandidateData.groundingMetadata.searchEntryPoint.renderedContent]
            : [],
        },
      };
    } catch (error) {
      const logger = getLogger("gemini_client");
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(`Gemini generation failed for prompt "${request.prompt.substring(0, 50)}...": ${errorMessage}`, error);
      throw new Error(
        `Gemini generation failed: ${errorMessage}`,
      );
    }
  }
}